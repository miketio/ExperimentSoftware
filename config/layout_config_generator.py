# layout_config_generator_v3.py
"""
Generate JSON layout configuration that exactly matches layout_models.py dataclasses.

This generator instantiates the dataclasses from layout_models and then
serializes to JSON using their to_dict-style representations so that the
produced files can be loaded directly with:
    - CameraLayout.from_json_file(...)
    - RuntimeLayout.from_json_file(...)

Usage:
    python layout_config_generator_v3.py <ascii_file> [output_json]

Example:
    python layout_config_generator_v3.py AlignmentSystem/ascii_sample.ASC config/mock_layout.json
"""
from pathlib import Path
import json
from typing import Dict, Tuple, Optional, List
import numpy as np
import config.layout_models as lm
from alignment_system.ascii_parser import ASCIIParser


def generate_layout_config_v3(
    ascii_files: List[str],  # CHANGED: Now accepts a list of file paths
    output_file: str = "config/mock_layout.json",
    design_name: str = "ArrayD_QuasiPeriodic_20Blocks",
    version: str = "2.1",
    coordinate_system: Optional[Dict[str, str]] = None,
    blocks_per_row: int = 5,
    num_rows: int = 4,
    block_spacing: float = 300.0,
    block_size: float = 200.0,
    simulated_rotation: float = 0.0,
    simulated_translation: Tuple[float, float] = (300.0, 200.0),
    block_rotation_std: float = 0.1,
    block_translation_std: float = 1.0,
    random_seed: int = 42,
    include_metadata: bool = True,
) -> Dict:
    """
    Build a layout configuration using the layout_models dataclasses and save JSON.
    
    Args:
        ascii_files: List of file paths, one per block. Length must match total blocks.
    """
    
    total_blocks = blocks_per_row * num_rows
    
    # Validation
    if len(ascii_files) != total_blocks:
        raise ValueError(f"Expected {total_blocks} ASCII files, got {len(ascii_files)}")

    if coordinate_system is None:
        coordinate_system = {
            "description": "All coordinates in micrometers (µm).",
            "origin": "Bottom-left corner of Block 1 at stage (0, 0)",
            "units": "micrometers",
            "axes": "Y_horizontal_Z_vertical"
        }

    # Create BlockLayoutParams dataclass
    block_layout = lm.BlockLayoutParams(
        block_size=float(block_size),
        block_spacing=float(block_spacing),
        blocks_per_row=int(blocks_per_row),
        num_rows=int(num_rows),
        total_blocks=int(total_blocks)
    )

    # Deterministic random per-block fabrication errors
    rng = np.random.default_rng(seed=int(random_seed))
    block_fab_errors: Dict[int, lm.BlockFabricationError] = {}
    for bid in range(1, total_blocks + 1):
        rot = float(rng.normal(0.0, float(block_rotation_std)))
        trans_u = float(rng.normal(0.0, float(block_translation_std)))
        trans_v = float(rng.normal(0.0, float(block_translation_std)))
        block_fab_errors[bid] = lm.BlockFabricationError(
            rotation_deg=rot,
            translation_um=lm.Point2D(u=trans_u, v=trans_v)
        )

    # Generation params dataclass
    gen_params = lm.GenerationParams(
        block_rotation_std_deg=float(block_rotation_std),
        block_translation_std_um=float(block_translation_std),
        random_seed=int(random_seed)
    )

    # Ground truth dataclass
    ground_truth = lm.GroundTruth(
        rotation_deg=float(simulated_rotation),
        translation_um=lm.Point2D.from_tuple((float(simulated_translation[0]), float(simulated_translation[1]))),
        block_fabrication_errors=block_fab_errors,
        generation_params=gen_params,
        description="Simulation ground truth (generated by layout_config_generator_v3.py)"
    )

    # Cache parsed files to improve performance if files are identical
    parsed_cache: Dict[str, dict] = {}

    # Build Blocks (design-only)
    blocks: Dict[int, lm.Block] = {}
    block_id = 1
    
    for row in range(num_rows):
        for col in range(blocks_per_row):
            
            # Get specific file for this block
            current_ascii_file = ascii_files[block_id - 1]
            
            # Parse or retrieve from cache
            if current_ascii_file in parsed_cache:
                parsed = parsed_cache[current_ascii_file]
            else:
                parser = ASCIIParser(current_ascii_file)
                parsed = parser.parse()
                parsed_cache[current_ascii_file] = parsed

            markers = {m['corner']: m['position'] for m in parsed['markers']}
            waveguides = parsed.get('waveguides', [])
            gratings = parsed.get('gratings', [])

            # design center (u, v)
            u_center = float(col * block_spacing)
            v_center = float(-1.0 * row * block_spacing) 
            
            # Fiducials
            fiducials: Dict[lm.CornerType, lm.Point2D] = {}
            for corner_key, pos in markers.items():
                try:
                    corner_enum = lm.CornerType(corner_key)
                except ValueError:
                    corner_enum = lm.CornerType(corner_key.lower())
                fiducials[corner_enum] = lm.Point2D.from_list([float(pos[0]), float(pos[1])])

            # Waveguides
            waveguide_objs: Dict[str, lm.Waveguide] = {}
            for wg in waveguides:
                wg_obj = lm.Waveguide.from_dict({
                    'number': int(wg['number']),
                    'v_center': float(wg['v_center']),
                    'width': float(wg['width']),
                    'u_start': float(wg['u_start']),
                    'u_end': float(wg['u_end'])
                })
                waveguide_objs[f"wg{wg_obj.number}"] = wg_obj

            # Gratings
            grating_objs: Dict[str, lm.Grating] = {}
            for g in gratings:
                v_gr = float(g['v_center'])
                if waveguides:
                    closest_wg = min(waveguides, key=lambda w: abs(w['v_center'] - v_gr))
                else:
                    closest_wg = None

                if closest_wg is not None:
                    gr_side = str(g['side'])
                    wg_number = int(closest_wg['number'])
                    gr_id = f"wg{wg_number}_{gr_side}"
                    gr_obj = lm.Grating(
                        position=lm.Point2D.from_list([float(g['position'][0]), float(g['position'][1])]),
                        side=lm.GratingSide(gr_side),
                        waveguide=wg_number
                    )
                    grating_objs[gr_id] = gr_obj

            block = lm.Block(
                id=int(block_id),
                row=int(row),
                col=int(col),
                size=int(block_size),
                design_position=lm.Point2D.from_list([u_center, v_center]),
                fiducials=fiducials,
                waveguides=waveguide_objs,
                gratings=grating_objs
            )

            blocks[block_id] = block
            block_id += 1

    output: Dict = {
        "design_name": design_name,
        "version": version,
        "coordinate_system": coordinate_system,
        "block_layout": block_layout.to_dict(),
        "blocks": {str(bid): blk.to_dict() for bid, blk in blocks.items()},
        "simulation_ground_truth": ground_truth.to_dict(),
    }

    if include_metadata:
        output["metadata"] = {
            "generated_by": "layout_config_generator_v3.py",
            "source_files_count": len(ascii_files),
            "notes": "Constructed using layout_models dataclasses; fabrication errors stored in simulation_ground_truth."
        }

    out_path = Path(output_file)
    out_path.parent.mkdir(parents=True, exist_ok=True)

    with open(out_path, 'w') as f:
        json.dump(output, f, indent=2)

    return output

def load_layout_config_v3(config_file: str = "config/mock_layout.json"):
    """
    Convenience loader that returns a CameraLayout instance (has ground truth).
    """
    return lm.CameraLayout.from_json_file(config_file)


def plot_layout_v3(layout_source, output_path: str = "config/mock_layout.png"):
    """
    Visualize layout using the dataclasses.
    """
    import matplotlib.pyplot as plt
    import numpy as np

    if isinstance(layout_source, str) or isinstance(layout_source, Path):
        camera = lm.CameraLayout.from_json_file(str(layout_source))
    elif isinstance(layout_source, dict):
        camera = lm.CameraLayout.from_dict(layout_source)
    elif isinstance(layout_source, lm.CameraLayout):
        camera = layout_source
    else:
        raise ValueError("plot_layout_v3 expects a path, dict, or CameraLayout instance")

    blk_layout = camera.block_layout
    block_size = blk_layout.block_size
    blocks = camera.blocks

    rotation_deg = camera.ground_truth.rotation_deg
    translation_um = camera.ground_truth.translation_um.to_list()

    plt.figure(figsize=(14, 12))
    plt.title(f"Layout: {camera.design_name}\n"
              f"Global Rotation = {rotation_deg:.2f}°, Global Translation = {translation_um} µm",
              fontsize=14)
    plt.xlabel("Stage Y / Design u (µm)", fontsize=12)
    plt.ylabel("Stage Z / Design v (µm)", fontsize=12)

    local_corners = np.array([
        [0.0, 0.0],
        [block_size, 0.0],
        [block_size, block_size],
        [0.0, block_size]
    ])

    def apply_block_fab_error(block_id: int, u_local: float, v_local: float):
        err = camera.ground_truth.get_block_error(block_id)
        rot = np.deg2rad(err.rotation_deg)
        trans_u = err.translation_um.u
        trans_v = err.translation_um.v
        u_rot = u_local * np.cos(rot) - v_local * np.sin(rot)
        v_rot = u_local * np.sin(rot) + v_local * np.cos(rot)
        return u_rot + trans_u, v_rot + trans_v

    def apply_global_transform(u_design: float, v_design: float):
        rot = np.deg2rad(camera.ground_truth.rotation_deg)
        trans_u, trans_v = camera.ground_truth.translation_um.to_list()
        u_stage = u_design * np.cos(rot) - v_design * np.sin(rot) + trans_u
        v_stage = u_design * np.sin(rot) + v_design * np.cos(rot) + trans_v
        return u_stage, v_stage

    legend_handles = [
        plt.Line2D([0], [0], color='gray', lw=1, label='Ideal Design'),
        plt.Line2D([0], [0], color='blue', lw=1.5, ls='--', label='Fabricated (Design + Fab Error)'),
        plt.Line2D([0], [0], color='red', lw=1.5, ls='--', label='Actual Stage (Fab + Global Transform)')
    ]

    for bid, block in blocks.items():
        u_center, v_center = block.design_position.to_tuple()
        u_bl = u_center - block_size / 2.0
        v_bl = v_center - block_size / 2.0

        # Ideal rectangle
        rect = plt.Rectangle((u_bl, v_bl), block_size, block_size,
                             edgecolor="gray", facecolor="none", lw=1.0)
        plt.gca().add_patch(rect)
        plt.text(u_center, v_center, str(bid), ha="center", va="center", fontsize=8, color="black")

        # Fabricated polygon
        fab_points = []
        for (u_l, v_l) in local_corners:
            u_fab_local, v_fab_local = apply_block_fab_error(bid, float(u_l), float(v_l))
            fab_points.append([u_bl + u_fab_local, v_bl + v_fab_local])
        poly_fab = plt.Polygon(fab_points, closed=True, edgecolor="blue", facecolor="none", lw=1.5, ls="--")
        plt.gca().add_patch(poly_fab)

        # Stage polygon
        stage_points = []
        for (u_l, v_l) in local_corners:
            u_fab_local, v_fab_local = apply_block_fab_error(bid, float(u_l), float(v_l))
            u_design = u_bl + u_fab_local
            v_design = v_bl + v_fab_local
            u_stage, v_stage = apply_global_transform(u_design, v_design)
            stage_points.append([u_stage, v_stage])
        poly_stage = plt.Polygon(stage_points, closed=True, edgecolor="red", facecolor="none", lw=1.5, ls="--")
        plt.gca().add_patch(poly_stage)

        # Fiducials
        plotted_labels = set()
        for corner_type, pos in block.fiducials.items():
            u_local, v_local = pos.to_tuple()
            u_fab_local, v_fab_local = apply_block_fab_error(bid, u_local, v_local)
            design_coord = (u_bl + u_fab_local, v_bl + v_fab_local)
            stage_coord = apply_global_transform(design_coord[0], design_coord[1])

            plt.scatter(design_coord[0], design_coord[1], s=15, marker='o', label=None)
            plt.scatter(stage_coord[0], stage_coord[1], s=20, marker='x', label=None)
            plt.plot([design_coord[0], stage_coord[0]], [design_coord[1], stage_coord[1]], color='orange', lw=0.5, alpha=0.7)

    handles, labels = plt.gca().get_legend_handles_labels()
    plt.legend(handles=legend_handles + handles, loc="upper right", fontsize=8, frameon=True)
    plt.axis("equal")
    plt.grid(True, ls="--", alpha=0.4)
    plt.tight_layout()

    Path(output_path).parent.mkdir(parents=True, exist_ok=True)
    plt.savefig(output_path, dpi=300)
    plt.show()
    print(f"Saved layout visualization to: {output_path}")

if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python layout_config_generator_v3.py <ascii_file> [output_json]")
        sys.exit(1)

    ascii_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else "config/mock_layout.json"
    
    # Define Grid here
    BLOCKS_PER_ROW = 5
    NUM_ROWS = 4
    TOTAL_BLOCKS = BLOCKS_PER_ROW * NUM_ROWS

    # CHANGED: Create a list of identical filenames for testing
    ascii_files_list = [ascii_file] * TOTAL_BLOCKS
    
    print(f"Using ASCII template: {ascii_file}")
    print(f"Generating {TOTAL_BLOCKS} blocks ({BLOCKS_PER_ROW}x{NUM_ROWS})")

    layout = generate_layout_config_v3(
        ascii_files=ascii_files_list,
        output_file=output_file,
        blocks_per_row=BLOCKS_PER_ROW,
        num_rows=NUM_ROWS,
        simulated_rotation=3.0,
        simulated_translation=(300.0, 200.0),
        block_rotation_std=5.0,
        block_translation_std=1.0,
        random_seed=42
    )

    print(f"\n✅ Layout config written to: {output_file}")